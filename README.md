# CVE-2022-0847 Exploits

## Dirty Pipe 

### O que é ?

Divulgada em 7 de março de 2022 por Max Kellerman[2], a CVE-2022-0847 é uma vulnerabilidade no kernel Linux (versões entre a 5.8 e 5.16.11) que permite que invasores substituam arquivos somente leitura ou imutáveis e aumentem seus privilégios no sistema da vítima. A CVE-2022-0847 foi apelidada de Dirty Pipe e possui uma pontuação CVSS de 7,8 (considerada alta).

### Como funciona a exploração da vulnerabilidade ?

A vulnerabilidade Dirty Pipe é descrita como uma falha na maneira como o atributo flags da struct pipe_buffer[7] não continha inicialização adequada nas funções copy_page_to_iter_pipe e push_pipe no kernel do Linux e, portanto, poderia conter valores obsoletos. Uma das flags que pode ser configurada no atributo flags da struct pipe_buffer é a flag chamada PIPE_BUF_FLAG_CAN_MERGE. Ela indica se a mesclagem de mais dados no pipe_buffer é permitida ou não. Dessa forma, quando os dados são copiados para um pipe_buffer, mais dados podem ser adicionados ao pipe_buffer se a página copiada tiver menos de 4096 bytes de tamanho. 

Ao injetar PIPE_BUF_FLAG_CAN_MERGE em uma referência de cache de página, tornou-se possível sobrescrever dados no cache de página, simplesmente escrevendo novos dados no pipe preparado de maneira especial(este processo será descrito nos parágrafos a seguir). Dessa forma, um usuário local sem privilégios pode usar essa falha para sobreescrever/gravar em páginas no cache de página apoiadas por arquivos somente leitura e, assim, aumentar seus privilégios no sistema.

Dito isso, para explorar a vulnerabilidade, as seguintes etapas devem ser seguidas:

1. Crie um pipe.
2. Preencha o pipe com dados arbitrários (para definir a flag PIPE_BUF_FLAG_CAN_MERGE em todas as entradas do array circular).
3. Drenar o pipe (deixando a flag PIPE_BUF_FLAG_CAN_MERGE definida em todas as instâncias de struct pipe_buffer do array circular). Normalmente, a flag deve ser redefinida. No entanto, a vulnerabilidade Dirty Pipe faz com que a flag permaneça definida como 1.
4. Transfira um arquivo somente leitura para o pipe usando a syscall splice.
5. Modifique o arquivo somente leitura. Como a chamada do sistema splice usa o método pass-by-reference (passagem por referência), o invasor pode sobrescrever o arquivo devido a flag PIPE_BUF_FLAG_CAN_MERGE.

## Exploits

Compile tudo com o comando a seguir:

```
make
```

### Exploit 1 - Sobrescrevendo Arquivos Somente Leitura

#### Rodando

```
./exploit-1
```

#### Descrição

O exploit 1, presente no arquivo exploit-1.c do repositório, consiste em sobrescrever a senha do usuário root presente no arquivo `/etc/passwd` (este arquivo contém informações sobre a conta de usuário, como a senha criptografada) e por fim, fornecer um terminal com acesso root. Para tanto, foi necessário:

1. Realizar um backup do arquivo `/etc/passwd`.
2. Preparar o pipe (conforme apresentado nas etapas 1, 2 e 3 da citadas acima) com a flag PIPE_BUF_FLAG_CAN_MERGE.
3. Transferir o arquivo `/etc/passwd` para o pipe e sobrescrever o conteúdo deste arquivo com uma nova senha de root conhecida (conforme apresentado nas etapas 4 e 5 da citadas acima).
4. Criar uma sessão como root a partir da nova senha definida.
5. Em seguida, a senha é redefinida para o valor original a partir do backup, assim sem deixar rastros.
6. Por fim, ainda com a sessão root estabelecida, um terminal shell com acesso root é liberado.

### Exploit 2 - Sequestro(Hijacking) de binários SUID

#### Encontrando binários SUID

```
find / -perm -4000 2>/dev/null
```

#### Rodando

```
./exploit-2 <path-of-suid-binary>
```

#### Descrição

O exploit 2, presente no arquivo exploit-2.c do repositório, consiste em sobrescrever a sequestrar um binário SUID(esse tipo de ataque foi relatado na seção 3.5.2) e por fim, fornecer um terminal com acesso root. Para tanto, foi necessário:

1. Preparar um código executável ELF(Executable and Linking Format) que será utilizado para sobrescrever o binário SUID recebido a ser recebido como parâmetro. No exploit, o executável ELF utilizado cria um novo um arquivo executável(`/tmp/sh`), que por sua vez, cria uma terminal shell com acesso root.
2. Receber o path de um binário SUID como parâmetro.
3. Realizar um backup do binário recebido.
4. Preparar o pipe (conforme apresentado nas etapas 1, 2 e 3 da citadas acima) com a flag PIPE_BUF_FLAG_CAN_MERGE.
5. Transferir o arquivo o binário recebido para o pipe e sobrescrever o conteúdo deste arquivo com o executável ELF da comentado na etapa 1 (conforme apresentado nas etapas 4 e 5 da citadas acima).
6. Em seguida, o binário recebido é restaurado para o seu conteúdo original a partir do backup, assim sem deixar rastros.
7. Por fim, o arquivo executável `/tmp/sh` citado na etapa 1 é executado, assim abrindo um novo shell com acesso root.

### Exploit 3 - Adição de chave para Acesso Remoto

#### Rodando

```
./exploit-3
```

#### Descrição

O exploit 3, presente no arquivo exploit-3.c do repositório, utiliza as mesmas etapas do exploit 1 para obter o acesso a shell root. A diferença é que exploit 3, após obter acesso ao shell root, carrega uma chave pública SSH(Secure Shell) do invasor no arquivo `/root/.ssh/authorized_keys` e cria um túnel TCP(Transmission Control Protocol) para acesso remoto ao SSH utilizando a plataforma [Ngrok](https://ngrok.com/).

## Referências

[1] AHMED, Alexis. Privilege Escalation Techniques: Learn the art of exploiting Windows and Linux systems. Birmingham: Packt Publishing, outubro de 2021.

[2] KELLERMANN, Max. The Dirty Pipe Vulnerability. Disponível em: <https://dirtypipe.cm4all.com/>. Acesso em: 23 de julho de 2022.

[3] Exploit Database. Disponível em: <https://www.exploit-db.com/>. Acesso em: 03 de agosto de 2022.

[4] Traitor: Automatically exploit low-hanging fruit to pop a root shell. Disponível em: <https://github.com/liamg/traitor>. Acesso em: 03 de agosto de 2022.

[5] PayloadsAllTheThings. Linux - Privilege Escalation. Disponível em: <https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md#cve-2022-0847-dirtypipe>. Acesso em: 03 de agosto de 2022.

[6] Repositório do Kernel do Linux - Struct pipe_inode_info. Disponível em: <https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L76>. Acesso em: 03 de agosto de 2022.

[7] Repositório do Kernel do Linux - Struct pipe_buffer. Disponível em: <https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L26-L32>. Acesso em: 03 de agosto de 2022.

[8] ARNTZ, Pieter. Linux "Dirty Pipe" vulnerability gives unprivileged users root access. Malwarebytes Lab. Disponível em: <https://www.malwarebytes.com/blog/news/2022/03/linux-dirty-pipe-vulnerability-gives-unprivileged-users-root-access>. Acesso em: 03 de agosto de 2022.

[9] Picus Security. Linux “Dirty Pipe” CVE-2022-0847 Vulnerability Exploitation Explained. Disponível em: <https://www.picussecurity.com/resource/linux-dirty-pipe-cve-2022-0847-vulnerability-exploitation-explained>. Acesso em: 03 de agosto de 2022.

[10] Exploit Database - Local Privilege Escalation (Dirty Pipe). Disponível em: <https://www.exploit-db.com/exploits/50808>. Acesso em: 03 de agosto de 2022.